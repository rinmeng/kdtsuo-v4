CREATE EXTENSION IF NOT EXISTS "moddatetime" WITH SCHEMA "extensions";

SET
    statement_timeout = 0;

SET
    lock_timeout = 0;

SET
    idle_in_transaction_session_timeout = 0;

SET
    client_encoding = 'UTF8';

SET
    standard_conforming_strings = on;

SELECT
    pg_catalog.set_config('search_path', '', false);

SET
    check_function_bodies = false;

SET
    xmloption = content;

SET
    client_min_messages = warning;

SET
    row_security = off;

CREATE SCHEMA IF NOT EXISTS "public";

ALTER SCHEMA "public" OWNER TO "pg_database_owner";

COMMENT ON SCHEMA "public" IS 'standard public schema';

SET
    default_tablespace = '';

SET
    default_table_access_method = "heap";

CREATE TABLE IF NOT EXISTS "public"."links" (
    "id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "label" "text",
    "iconType" character varying,
    "date" "date",
    "link" "text",
    "user_id" "uuid",
    "price" double precision,
    "order" bigint
);

ALTER TABLE
    "public"."links" OWNER TO "postgres";

ALTER TABLE
    "public"."links"
ALTER COLUMN
    "id"
ADD
    GENERATED BY DEFAULT AS IDENTITY (
        SEQUENCE NAME "public"."links_id_seq" START WITH 1 INCREMENT BY 1 NO MINVALUE NO MAXVALUE CACHE 1
    );

CREATE TABLE IF NOT EXISTS "public"."positions" (
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "label" "text",
    "form_url" "text",
    "is_accepting_responses" boolean,
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "description" "text"
);

ALTER TABLE
    "public"."positions" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."sponsors" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "title" "text" NOT NULL,
    "image" "text" NOT NULL,
    "location" "text" NOT NULL,
    "maplink" "text" NOT NULL,
    "text" "text" NOT NULL,
    "websitelink" "text" NOT NULL,
    "user_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE
    "public"."sponsors" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."team_members" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "full_name" "text" NOT NULL,
    "role" "text" NOT NULL,
    "bio" "text",
    "profile_image_url" "text",
    "instagram_url" "text",
    "linkedin_url" "text",
    "github_url" "text",
    "order_index" integer,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "is_archived" boolean DEFAULT false
);

ALTER TABLE
    "public"."team_members" OWNER TO "postgres";

ALTER TABLE
    ONLY "public"."links"
ADD
    CONSTRAINT "links_pkey" PRIMARY KEY ("id");

ALTER TABLE
    ONLY "public"."positions"
ADD
    CONSTRAINT "positions_pkey" PRIMARY KEY ("id");

ALTER TABLE
    ONLY "public"."sponsors"
ADD
    CONSTRAINT "sponsors_pkey" PRIMARY KEY ("id");

ALTER TABLE
    ONLY "public"."team_members"
ADD
    CONSTRAINT "team_members_pkey" PRIMARY KEY ("id");

CREATE INDEX "sponsors_user_id_idx" ON "public"."sponsors" USING "btree" ("user_id");

CREATE
OR REPLACE TRIGGER "handle_updated_at" BEFORE
UPDATE
    ON "public"."team_members" FOR EACH ROW EXECUTE FUNCTION "extensions"."moddatetime"('updated_at');

ALTER TABLE
    ONLY "public"."sponsors"
ADD
    CONSTRAINT "sponsors_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id");

CREATE POLICY "Authenticated user can modify their own sponsors" ON "public"."sponsors" USING (("auth"."role"() = 'authenticated' :: "text")) WITH CHECK (("auth"."role"() = 'authenticated' :: "text"));

CREATE POLICY "Authenticated users can modify their own links" ON "public"."links" USING (("auth"."role"() = 'authenticated' :: "text")) WITH CHECK (("auth"."role"() = 'authenticated' :: "text"));

CREATE POLICY "Authenticated users can modify their own positions" ON "public"."positions" USING (("auth"."role"() = 'authenticated' :: "text")) WITH CHECK (("auth"."role"() = 'authenticated' :: "text"));

CREATE POLICY "Only authenticated users can modify team_members" ON "public"."team_members" USING (("auth"."role"() = 'authenticated' :: "text")) WITH CHECK (("auth"."role"() = 'authenticated' :: "text"));

CREATE POLICY "Public can read links" ON "public"."links" FOR
SELECT
    USING (true);

CREATE POLICY "Public can read positions" ON "public"."positions" FOR
SELECT
    USING (true);

CREATE POLICY "Public can read sponsors" ON "public"."sponsors" FOR
SELECT
    USING (true);

CREATE POLICY "Public can read team_members" ON "public"."team_members" FOR
SELECT
    USING (true);

ALTER TABLE
    "public"."links" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
    "public"."positions" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
    "public"."sponsors" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
    "public"."team_members" ENABLE ROW LEVEL SECURITY;

GRANT USAGE ON SCHEMA "public" TO "postgres";

GRANT USAGE ON SCHEMA "public" TO "anon";

GRANT USAGE ON SCHEMA "public" TO "authenticated";

GRANT USAGE ON SCHEMA "public" TO "service_role";

GRANT ALL ON TABLE "public"."links" TO "anon";

GRANT ALL ON TABLE "public"."links" TO "authenticated";

GRANT ALL ON TABLE "public"."links" TO "service_role";

GRANT ALL ON SEQUENCE "public"."links_id_seq" TO "anon";

GRANT ALL ON SEQUENCE "public"."links_id_seq" TO "authenticated";

GRANT ALL ON SEQUENCE "public"."links_id_seq" TO "service_role";

GRANT ALL ON TABLE "public"."positions" TO "anon";

GRANT ALL ON TABLE "public"."positions" TO "authenticated";

GRANT ALL ON TABLE "public"."positions" TO "service_role";

GRANT ALL ON TABLE "public"."sponsors" TO "anon";

GRANT ALL ON TABLE "public"."sponsors" TO "authenticated";

GRANT ALL ON TABLE "public"."sponsors" TO "service_role";

GRANT ALL ON TABLE "public"."team_members" TO "anon";

GRANT ALL ON TABLE "public"."team_members" TO "authenticated";

GRANT ALL ON TABLE "public"."team_members" TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "postgres";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "anon";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "authenticated";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "postgres";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "anon";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "authenticated";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "postgres";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "anon";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "authenticated";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "service_role";